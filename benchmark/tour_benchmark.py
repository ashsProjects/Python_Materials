import random, requests, json, time, sys
import matplotlib.pyplot as plt
import numpy as np
from scipy.optimize import curve_fit

'''
You can define the server by changing the last two numbers to the appropriate
server. Use either ther server or localhost, but uncomment the other one.
'''
# url = 'https://black-bottle.cs.colostate.edu:31412/api/tour'
url = 'http://127.0.0.1:41312/api/tour'

def generate_test_file(num_tests=500, seed=None) -> None:
    '''
    This method will generate json request files for the tour api. This can be used in Postman
    to test tour responses and time.
    
    Args:
        num_tests (int): how many places to generate; default is 500
        seed (int): random seed to use; default is None
    '''
    file = open('testfile.json', 'w')
    file.write('{\n\t"requestType": "tour",')
    file.write('\n\t"earthRadius": 1234,')
    file.write('\n\t"response": 1,')
    file.write('\n\t"places": [')
    
    random.seed(seed) #change seed or remove
    for i in range(num_tests):
        latitude = random.randint(-90, 90)
        longitude = random.randint(-180, 180)
        
        file.write('\n\t\t{\n')
        file.write(f'\t\t\t"latitude": "{latitude}",\n')
        file.write(f'\t\t\t"longitude": "{longitude}"\n')
        
        if i == num_tests - 1: 
            file.write('\t\t}\n')
            break
        
        file.write('\t\t},\n')
    
    file.write('\t]\n')
    file.write('}\n')

def generate_distances(num=500, seed=None) -> None:
    '''
    This method will generate a json file with places with random coordinates.
    It can be used to load places onto the map using the app.
    
    Args:
        num (int): the number of places to generate; deaults to 500
        seed (int): the random seed to use; defaults to None
    '''
    random.seed(seed)
    file = open('distances.json', 'w')
    file.write('{\n\t"places": [')
    
    for i in range(num):
        latitude = random.randint(-90, 90)
        longitude = random.randint(-180, 180)
        
        file.write('\n\t\t{\n')
        file.write(f'\t\t\t"latitude": "{latitude}",\n')
        file.write(f'\t\t\t"longitude": "{longitude}",\n')
        file.write(f'\t\t\t"name": "{i}",\n')
        file.write(f'\t\t\t"municipality": "{i}",\n')
        file.write(f'\t\t\t"region": "{i}"\n')
        if i == num - 1: 
            file.write('\t\t}\n')
            break
        file.write('\t\t},\n')
    
    file.write('\t]\n')
    file.write('}\n')

def send_to_server(verbose=False, timeout=15) -> tuple[int, float]:
    '''
    This method will send the json file generated by generate_test_file().
    If verbose is true, it will print out the status code and response time from the server.
    
    Args:
        verbose (bool): prints the status code, time, and json response from the server if true
        timeout (int): timeouts after no response from server; default is 15
    
    Returns:
        A tuple with the status and time returned by the server
    '''
    with open('testfile.json', 'r') as file:
        json_data = json.load(file)
    
    session = requests.Session()
    start = time.time()
    response = session.post(url, json=json_data, verify='cs314.pem', timeout=timeout)
    end = time.time()
    response_time = end - start 
    response_status = response.status_code
    
    if verbose:
        print(f'SERVER RESPONSE:')
        print(f'STATUS CODE: {response_status}')
        print(f'TIME ELAPSED: {response_time}s')
        
        pretty_json = json.loads(response.text)
        with open('server_response.json', 'w') as file:
            file.write(json.dumps(pretty_json, indent=2))
            
    return (response_status, response_time)

def cubic_polynomial_func(x, a, b, c, d):
    '''
    Used by scipy.optimize() to fit a cubic function to the data
    '''
    return a * x**3 + b * x**2 + c * x + d

def compute_average_function(x, y) -> None:
    '''
    Computes a, b, c, and d after fitting a cubic function to the data and takes
    the avergae of 10 different iterations. It will print out the function that
    can be used to predict how long it takes to compute the optimized tour.
    
    Args:
        x (ndarray): array of places
        y (ndarray): array of response time
    '''
    a = []; b = []; c = []; d = []
    
    for i in range(10): #increase if needed
        params, _ = curve_fit(cubic_polynomial_func, x, y)  #covariance will not be calculated when 
        ai, bi, ci, di = params                             #there are not enough values or they are really small
        a.append(ai); b.append(bi); c.append(ci); d.append(di)
        
    a_mean = np.mean(a); b_mean = np.mean(b); c_mean = np.mean(c); d_mean = np.mean(d)
    print(f'Equation: {a_mean:.10f}x^3 + {b_mean:.10f}x^2 + {c_mean:.10f}x + {d_mean:0.10f}')

def benchmark(iterations=1, intervals=50, max_tests=2000, max_seconds=1, verbose=True) -> None:
    '''
    This method will benchmark the server define in the send_to_server method. It will iterate
    iterations number of time and send requests to the server using post in intervals until
    max_tests. If verbose is true, it will generate a graph of the results with the number of
    places as the x and response time as y. The test data is used to fit a function and is printed.
    If your algorithm is slow, might not want to run that many tests. It will also help to have
    the terminal for the app open to the side.
    
    Args:
        iterations (int): number of times to run the tests; high nums will not work as server stops responding
        intervals (int): number by which to generate tests; default is 50
        max_tests (int): number of places at which to stop; default is 2000
        max_seconds (int): used when plotting; default is 1
        verbose (bool): prints information about the progress and creates a graph with response        
    '''
    results = []
    for iter in range(iterations):
        for i in range(0, max_tests, intervals):
            generate_test_file(i)
            try:
                status, time = send_to_server()
            except:
                continue
            print(f'Completed {iter}:{i}')
            if status >= 400: raise Exception #could be because server returned 500 for 0 places
            results.append([i, time])
    results = np.array(results, dtype=np.float32)
    
    results_mean = []
    for i in range(0, max_tests, intervals):
        filtered_row = results[results[:,0] == i]
        results_mean.append([i, np.mean(filtered_row[:,1])])
    results_mean = np.array(results_mean, dtype=np.float32)        
       
    if verbose:
        for r in results:
            print(f'Num tests: {r[0]}; Time: {r[1]:.5f}')
            
        plt.plot(results_mean[:,0], results_mean[:, 1])
        plt.axhline(max_seconds, color='r')
        plt.xlabel("Num Tests")    
        plt.ylabel("Seconds to Complete")
        plt.savefig('results.png')
    
    compute_average_function(results_mean[:, 0], results_mean[:, 1])
    
if __name__ == '__main__':
    '''Use if you want to generate tour response to use in Postman; uncomment'''
    # generate_test_file(num_tests=2000)
    
    '''Use if you want to genearte places so you can test the map using the app; uncomment'''
    # generate_distances(num=500)
    
    '''Use if you want to send a single request to the server; uncomment'''
    # send_to_server(verbose=True)
    
    '''Use if you want to benchmark your server/algorithm; uncomment'''
    # benchmark(iterations=3, max_tests=2000)
    